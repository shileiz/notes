# 运算符优先级专题

## 参考
* `http://blog.csdn.net/skywalker_leo/article/details/6237222`

## 基本原则

* 运算符分为1~15共15个优先级，1级最高，15级最低。  
	* 1级：初等运算符（4个）： `[]，()，->, .`
	* 2级：单目运算符（9个）：`-，(类型)，++，--，*，&，!，~，sizeof`
	* 3级：算数运算符中的乘除取余（3个）：`*，/，%`
	* 4级：算数运算符中的加减（2个）：`+，-`
	* 5级：算数运算符中的位移（2个）：`>>，<<`  

* 相同等级的，按结合方向决定谁先运算。
	* 大多数运算符都是从左向右结合的。
	* 只有以下几类运算符是从右向左结合的：单目运算符，三目运算符，赋值运算符 
	
			* 与 / 具有相同的优先级别，其结合方向为自左向右，因此 3 * 5 / 4 的运算次序是先乘后除
			- 和 ++ 为同一优先级，结合方向为自右向左，因此 - i ++ 相当于 - ( i ++ )
			char* p = "hello";
			*p++; // 相当于 *(p++)，结果是指向 e 的指针。
			++*p; // 相当于 ++(*p)，是错误。因为常量的值不能改变。

* 编译器在解读表达式时，按照从左到右，按‘贪婪’模式形成表达式。即尽可能多的读入字符组成表达式。

		a+++b; 
		// 单目运算符++的优先级高于算数运算符+ ,所以以上表达式可以解读为 (a++)+b 或者 a+(++b);
		// 因为贪婪模式，编译器会读到第二个加号为止形成 a++ 这个表达式才停下来。所以结果是 (a++)+b 

## 看两道题
#### 问题1：`int*a[5];` 为什么不表示 a pointer to an array？
* 因为[]的优先级高于`*`，a先与[5]结合——a首先是一个有5个元素的数组，然后再与`int*`结合，a这个数组里装的都是指向int的指针。
* 再看`int(*a)[5];`，()优先级最高，a首先与`*`结合——a首先是一个指针，然后a指向的是int[5]类型的数组

#### 问题2：详细分析如下程序的运算过程
	int a = 7;
	float x = 2.5, y = 4.7;
	x + a % 3 * (int)(x + y) % 2 / 4

	/*
		分析：此表达式中运算优先级排序
		1：优先级最高的是(x+y),初等运算符()优先级为1。所以第1步计算 (x + y)。
		2：(int)单目运算符优先级为2。所以第2步计算 	(int)(x + y)
		3：剩下的运算符都是算数运算符，其中乘除取余都是优先级3，加减法优先级4。
		   而算数运算符结合顺序为左到右。所以第3步应该是乘除取余中最左边的那个：a % 3
		4: 继续进行从左到右的乘法：a % 3 * (int)(x + y)
		5：继续进行从左到右的取余：a % 3 * (int)(x + y) % 2
		6：继续进行从左到右的除法：a % 3 * (int)(x + y) % 2 / 4
		7：最后进行优先级最低的加法：x + a % 3 * (int)(x + y) % 2 / 4
		分析：计算中的类型隐转
		1：(x + y)： 两个都是 float，没有混合运算直接加，结果是 7.2
		2：(int)(x + y)：float 强转 int，小数部分丢失，结果是 7
		3：a % 3：取余运算只能对整数进行，这里 a 和 3 都是整数，没有问题。结果是 1
		4：a % 3 * (int)(x + y)：相当于1 * 7，两个整数相乘，结果是整数 7
		5：a % 3 * (int)(x + y) % 2：相当于 7 % 2，结果是整数 1
		6：a % 3 * (int)(x + y) % 2 / 4：相当于 1 / 4 ，两个整数相除，结果是整数 0
		   这里要注意，虽然 1/4=0.25，但这里整数除以整除，结果还是整数，小数部分被直接舍去了
		7：x + a % 3 * (int)(x + y) % 2 / 4：相当于 2.5 + 0，浮点加整数，都转换为double计算，结果是double型的 2.5
	*/
	double d;
	d = x + a % 3 * (int)(x + y) % 2 / 4;
	printf("%lf",d); // 2.500000

