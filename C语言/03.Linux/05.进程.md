## 01.虚拟地址（了解即可，先不用太透彻）
* 每个进程可寻址空间都是0~3G，这是虚拟地址，即便机器实际内存只有512M。
* 每个进程都有一个PCB，PCB是操作系统的一个数据结构。每当新建一个进程，操作系统就建一个PCB结构体变量（在kernel区）来管理这个进程。
* Linux用 task_struck 结构体来描述PCB。其中有一个字段就是描述虚拟内存地址空间信息的。
* 每个进程有自己的 栈、堆、代码（静态）空间。这些都是用户空间。进程可以读写。
* kernel 空间对于所有进程来说都是同一份。用户进程无法写kernel空间。
* 3G~4G是kernel内存空间，用户进程无权访问。
* 操作系统按照page来管理内存，当你 malloc 1KB 内存时，操作系统实际会开辟一个page（4096Bytes）的内存。Windows也是4096一个page吗？
* 每个page有自己的R/W权限
* Intel CPU 的工作级别分为0~3级。0级是内核态，只有这时才能访问3G~4G这段内存地址空间。而用户进程运行时cpu处于3级，即用户态。
* 0级工作状态的CPU理论上对所有page都有读写权限，而3级工作状态的CPU只对部分page有读写权限，这是操作系统控制的
* 当用户进程进行系统调用的时候（比如 printf，printf会调用sys_write，sys_write会触发系统软中断），CPU状态会由3切换到0。

## 02.进程状态
* PCB（即Linux的 task_struck）里还有一个字段是“文件描述符表”，表里是很多指向file结构体的指针。本进程打开的所有file在此记录。

## 内存分区（由低到高，仅描述进程的用户区）

##### 见图 `00_基础班/06_字符串(20140706)/C基础.jpg`上的截图
* 代码段（Text/Code Segment）： 由exec从程序的二进制文件读入内存。存放程序代码（包含所有函数的入口地址）。
* 字符串常量区（RO.Data Segment）： 由exec从程序的二进制文件读入内存。存放只读数据。
* 全局变量区（静态变量区）： 由exec从程序的二进制文件读入内存。存放全局变量和静态变量（静态变量也是全局变量，只是仅在本文件内有效其他文件不可见而已）。
	*  全局变量区就是静态变量区。
	*  全局变量区又细分为：已初始化的全局变量区（Data Segment）和未初始化的全局变量区（BSS Segment）。
		* 已初始化的全局变量直接由exec读入内存
		* 未初始化的全局变量由exec赋初值0
* 堆区（Heap Segment）： malloc、new分配。  
* 栈区（Stack Segment）：存放局部变量。  
