## 01.虚拟地址（了解即可，先不用太透彻）
* 每个进程可寻址空间都是0~3G，这是虚拟地址，即便机器实际内存只有512M。
* 每个进程都有一个PCB，PCB是操作系统的一个数据结构。每当新建一个进程，操作系统就建一个PCB结构体变量（在kernel区）来管理这个进程。
* Linux用 task_struck 结构体来描述PCB。其中有一个字段就是描述虚拟内存地址空间信息的。
* 每个进程有自己的 栈、堆、代码（静态）空间。这些都是用户空间。进程可以读写。
* kernel 空间对于所有进程来说都是同一份。用户进程无法写kernel空间。
* 3G~4G是kernel内存空间，用户进程无权访问。
* 操作系统按照page来管理内存，当你 malloc 1KB 内存时，操作系统实际会开辟一个page（4096Bytes）的内存。Windows也是4096一个page吗？
* 每个page有自己的R/W权限
* Intel CPU 的工作级别分为0~3级。0级是内核态，只有这时才能访问3G~4G这段内存地址空间。而用户进程运行时cpu处于3级，即用户态。
* 0级工作状态的CPU理论上对所有page都有读写权限，而3级工作状态的CPU只对部分page有读写权限，这是操作系统控制的
* 当用户进程进行系统调用的时候（比如 printf，printf会调用sys_write，sys_write会触发系统软中断），CPU状态会由3切换到0。

## 02.进程状态
* PCB（即Linux的 task_struck）里还有一个字段是“文件描述符表”，表里是很多指向file结构体的指针。本进程打开的所有file在此记录。
* 每个进程的PCB都是在内存的 kernel 区，只有操作系统才能访问
* 每个进程除了常说的内存分区以外，还在比栈区更高的地址处，即紧邻 kernel 区的地方，占用了一个小块区域，来存储环境变量和命令行参数。

### 进程的环境变量
* 每个进程有自己的环境变量。
* libc 中定义的全局变量 `char** environ` 指向环境变量表，`environ` 没有包含在任何头文件中，所以在使用时要用 `extern` 声明。

		#include<stdio.h>
		int main(void)
		{
			extern char**environ;
			int i;
			for(i=0;environ[i]!=NULL;i++)
			printf("%s\n",environ[i]);
			return 0;
		}
* 由于父进程在调用fork创建子进程时会把自己的环境变量表也复制给子进程，所以 a.out 打印的环境变量和Shell进程的环境变量是相同的。（实际实验还是略有区别的，比如 `_=./a.out` 这是 a.out 输出的，而 `_=/usr/bin/env` 这是 env 输出的。具体还要看看env这个程序是干嘛的，这里就不细看了）

#### getenv 和 setenv
* 这俩也是标准C定义的函数，在 stdlib.h 里
* 函数原型如下：

		int setenv(const char *name, const char *value, int overwrite); // 成功返回0，出错返回非0。rewrite非0，覆盖原来的定义；若rewrite为0，则不覆盖原来的定义，也不返回错误。
		int unsetenv(const char *name);
		char *getenv(const char *name); // 返回值是指向value的指针，若未找到则为NULL。
* 例子程序

		#include<stdlib.h>
		#include<stdio.h>
		int main(void)
		{
			printf("PATH=%s\n",getenv("PATH"));
			setenv("PATH","hello",1);
			printf("PATH=%s\n",getenv("PATH"));
			return 0;
		}

### 进程状态转换
* 进程有四种状态：运行、就绪（万事俱备，就等着CPU时间片轮到自己）、睡眠（被阻塞的进程，比如正在进行阻塞IO，比如调用了sleep函数）、停止（自己exit或者被kill）。

## 进程原语
* 3个进程原语：fork、exec、wait
* 这3个进程原语都是 POSIX 特有的系统函数
* 注意：一个进程在内存里是占用kernel区和用户区各一些内存的。

### fork
* fork 调用，立马起一个子进程。父进程继续执行。
* 子进程创建时，用户区内存完全复制父进程的。PCB也复制父进程的，但是PID会改一下。
* fork 的原型：`pid_t fork(void);`
* fork 需要包含： `#include <unistd.h>`
* fork “调用一次返回2次”：在父进程返回子进程的PID，在子进程返回0.

#### fork 的几点注意
* 子进程是从父进程clone出来的，虽然子进程的代码段跟父进程完全相同，但子进程从 `fork()；` 返回之后的语句开始执行。
* 所以在调用 fork 之后，我们要用它的返回值来做个分支，子进程干的事儿写在大于0的分支，父进程干的事儿写在等于0的分支。
* 子进程的栈空间也是从父进程clone来的，所以父进程拥有的栈空间变量子进程同样拥有，而且子进程里这些变量的初始值就是fork当时父进程里的值。

#### 读时共享 写时赋值
* 操作系统为了效率，肯定不是 fork 的时候，真的把物理内存赋值了一份给子进程
* 实际 clone 的时候，只是把父进程的物理内存也映射给了子进程一份（父进程本身的内存也是从物理内存上映射来的）
* 只有当子进程要修改变量的时候，才会发生真正的物理内存赋值。即所谓的 copy on write

## 内存分区（由低到高，仅描述进程的用户区。每一个进程在用户区都有这么多个内存区域）

##### 见图 `00_基础班/06_字符串(20140706)/C基础.jpg`上的截图
* 代码段（Text/Code Segment）： 由exec从程序的二进制文件读入内存。存放程序代码（包含所有函数的入口地址）。
* 字符串常量区（RO.Data Segment）： 由exec从程序的二进制文件读入内存。存放只读数据。
* 全局变量区（静态变量区）： 由exec从程序的二进制文件读入内存。存放全局变量和静态变量（静态变量也是全局变量，只是仅在本文件内有效其他文件不可见而已）。
	*  全局变量区就是静态变量区。
	*  全局变量区又细分为：已初始化的全局变量区（Data Segment）和未初始化的全局变量区（BSS Segment）。
		* 已初始化的全局变量直接由exec读入内存
		* 未初始化的全局变量由exec赋初值0
* 堆区（Heap Segment）： malloc、new分配。  
* 共享库
* 栈区（Stack Segment）：存放局部变量。  
