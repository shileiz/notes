## C语言里嵌入汇编
* 不同的编译器语法不一样（不是C语言语法，是编译器利用C语法自己定的一种格式，所以各家编译器不一样）
* VS 里用 `__asm{...}`。因为汇编语句以行为单位，每句话占一行，所以汇编语句不用加分号

		int a =10;
		int b;    // 以下汇编相当于 b=a+5;
		__asm
		{
			mov eax, a
			add eax, 5
			mov b, eax
		}

## register 关键字（不常用）
* register 是C的关键字，它的作用是“建议”编译器把变量放到寄存里，但只是建议，因为寄存器可能不够用
* 现代编译器的优化已经很好，一般不需要程序员手工指定寄存器变量
* 寄存器是没有地址的，对寄存器变量取地址是非法的

		register  int a = 3;
		&a;    //地址是内存的地址，CPU没有地址

## 内存分区
* 没什么新内容，只是这个老师简化了一下，只分四个区：栈、堆、静态区、代码区
* 把字符串常量区（RO.Data Segment）算在了代码区内
* 静态区（全局变量区）也没有细分为已初始化的全局变量区（Data Segment）和未初始化的全局变量区（BSS：Block by Start Symbol）

## 声明和定义
* 声明可以重复声明，定义不能重复定义，因为定义时会在内存开辟空间。
* 全局变量，赋初值属于定义，不赋初值是声明

		/*在所有函数之外*/
		int a=10；
		int a=20；// 错误，重复定义

		/*在所有函数之外*/
		int a；
		int a；// 合法，可以声明多次

* 局部变量无论是否赋初值，都是定义

		void test()
		{
			int a;
			int a;   // 错误，重复定义
		} 

## 全局变量
* 全局变量可以跨文件

		/* main.c 在所有函数之外 */
		int a=10；

		/* calc.c 在所有函数之外 */ 
		int a；// 合法，声明
		int a=20; // 错误，重复定义，已经在main.c定义过了

## static变量

### static 局部变量
0. 局部静态变量，也在内存的全局数据区（Data Segment）
1. 只在语句块内可见

		for(i=0;i<10;i++)
		{
			static int b = 10;
		}
		printf("%d",b); // 错误，出了for语句块，b就不可见了

2. 只初始化一次

		for(i=0;i<10;i++)
		{
			static int b = 10; // 第二次进到for的时候，不再执行此句，因为静态变量只初始化一次
			printf("%d\n",b);  // 10,11,12,...
			b++;
		}
		
3. 必须用常量初始化

		int i;
		int j = i; // 合法，变量可以用变量初始化。
		static int k = i; // 不合法，静态变量必须用常量初始化。

### static 全局变量
* 只在本文件可见
* 其他文件用 extern 也引用不到

## const 伪常量
* 真正的常量是不能直接取地址的（字符串常量可以）
	* 能直接被CPU处理的常量（所有C基本类型，2类6种）实际上也没有地址，都在寄存器里呢。  
	所以对他们取地址不合法：`&10` 不合法。VS2015报错：常量上的'&'
	* 不能直接被CPU处理的常量（字符串常量）有地址，因为字符串不可能直接放到寄存器里，肯定在内存上。  
	这种是可以取到地址的：`&"hello"` 合法，能取到字符串常量区的地址。
* const 变量是可以取地址的，并且可以通过地址改变它的值

		const int n=10;
		int* p = &n;   // 合法，const变量可以取地址
		*p = 100;      // 通过地址，间接的改变了const变量的值
		printf("%d",n);  // 100