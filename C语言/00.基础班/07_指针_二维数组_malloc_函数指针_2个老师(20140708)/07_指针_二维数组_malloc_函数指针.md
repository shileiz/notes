## 二维数组

#### 二维数组
* 最直观的理解是：行、列。`int a[3][5];` 一个3行5列的矩阵。
* a每加1移动一行。a初始指向第一行的第一个元素，而a+1指向第二行的第一个元素。

#### 二维数组与指向数组的指针（行指针）
* 二维数组有点类似于指向数组的指针。
* 定义一个指向数组的指针要这样（还记得吗？）： `int(*p)[5];` p 是一个指向 int[5] 的指针。
* 二维数组 `int a[][5];` 可以理解为 a 是一个指向 int[5] 的指针。
* 根据以上，`int(*p)[5];` / `int a[][5];` p 和 a 被称作‘行指针’，因为他们是指向一行的指针。他们每加1,跨越一行。
*  `int a[3][5];` 可以理解为 a 是一个长度为3的数组，a 里面装了 3 个 int[5] 类型的数组。
* 换句话说，你可以理解为 a 是一个装了类型为 int[5] 的元素的数组。 

#### 为什么定义二维数组时，可以不写行数只写列数？
* 根据上面的理解，a 是一个装了类型为 int[?] 的元素的数组，你连?是几都不说显然是不行的，这相当于没有告诉编译器a里面装的是啥类型。
* int[2] 和 int[5] 可是两种完全不同的类型！

#### 一维/二维数组的初始化
* `int a[];` 是非法的，VS2015 会报错说，a:未知的大小。
* 而 `int a[] = {1，2};` 是合法的，因为编译器会从初始化的值中，得知a的长度为2.
* 二维数组也是同样的道理
* `int a[][5];` 非法，你没告诉编译器a多长。VS2015 会报错说，a:未知的大小。
* 而  `int a[][5] = {{1,2,3,4,5}};` 是合法的，相当于你告诉了编译器a的长度是1。

#### 数组作为参数传递
* 先看一维数组：当你定义一个函数的时候，`void foo(int a[], int n){...}`
* （还记得吗？）首先，因为数组会退化为指针，所以你要多传一个参数 n 来告诉函数，这个数组有多长。
* 其次，你的形参写的是 `int a[]`，而不是 `int a[5]`，因为你只需要告诉编译器，这个参数是一个 `int[]` 型的就可以了。对了，因为退化的问题，编译器实际上只会拿它当成 `int*` 来用。
	* 其实，即便你定义函数的时候，写的是  `void foo(int a[5]){...}`（这样写是合法的）
	* 这个 5 也是没用的。编译器只会知道 a 是一个指向 int 的指针，不知道 a 多长。
* 二维数组同理。当你书写函数的形参的时候，直接写 `int a[][5]` 是合法的，因为这时你只是在告诉编译器，形参 a 的类型是 `int [][5]`，即指向`int[5]` 的指针。


##  外挂

* 其实重点是怎么获取其他进程里变量的地址，目前为止老师没讲。
* 老师说那个在内存中搜索变量的工具是他自己用C++写的，要学完C++才能做。用纯C也能做，不过太费劲。
* 另外需要注意的是，windows中（windows xp 之后）一个进程不能去修改属于另外一个进程的内存。所以开发外挂要做成dll，把dll注入到被挂的进程中去。
* 并且你做的dll里的函数，需要加上` _declspec(dllexport) `前缀，你的函数才能在dll加载时自动被调用。
* ` _declspec(dllexport) `是个什么玩意老师没有展开讲，看起来有点儿像装饰器。
* 不过什么是dll注入老师也没展开讲。

## 函数指针( a pointer to a function )
* 函数指针的定义： ` 返回值类型 (*指针变量名)(函数参数表列); ` 例如：

		int (*p)(int,int);
	* 定义p是指向函数的指针变量，它指向返回值为整型且有两个整型参数的函数。
	* p的类型用`int (*)(int,int)`表示
	* p+n,p++,p--等运算无意义
	* 比如你有一个函数：`int add(int a, int b)`。则你可以给 p 赋值：`p = add;`
* 使用函数指针：`指针变量名(函数参数表列);`

		p(2,3); // 相当于 add(2,3);

## 堆空间：malloc 和 free
* malloc 分配堆空间上的内存。堆空间上的内存分配后不会自动回收，只能手动回收。用 free 进行回收。
* malloc 的返回值是分配空间的首地址，其类型是 `void*`。如果分配失败则返回 NULL。
* 根据自己的需要对 malloc 返回的地址指针类型进行强转。
* 例：在堆内存上分配一个长度为1000的 int 数组并初始化。

		int* p = (int*) malloc(sizeof(int)*1000);
		int i;
		for(i=0，i<1000,i++)
		{
			*p = 0;
			p++;
		}
* free 的参数是malloc返回的那个内存地址: `free(p);`
* free 之后，p 的值不变，p 仍然是栈空间的上的一个指针型变量，指向堆空间上的那片地址。
* 但是，如果 free 之前就给 p 重新赋值了（或者跳出了 p 的作用域，p 消亡了），那么将永远无法 free 掉这片内存，将会造成内存泄露。
* 对同一个地址 free 两次，会引起程序崩溃。

		int *p=(int*)malloc(10*sizeof(int));
		if(p==NULL)  /*防错处理，看内存申请是否成功*/
		{
			printf("内存申请失败，退出");
			return;
		}
		int *z=p;
		free(p); /*释放动态内存*/
		free(z);/*再次释放内存， 程序会崩溃*/



## 栈空间：栈溢出
* 每个进程的栈空间是有限的，VS工程可以修改程序的栈空间大小。如果在栈上使用了过多的空间会造成栈溢出（Stack Overflow）。

##  指针函数(a function returns a pointer)
* 返回指针的函数，跟别的函数没什么区别，比如： `int* foo(int a, int b);`
* 做题：