## 再提运算符优先级
* （复习）还记得上次的 * 和 [] 吗？ 哪个优先级高？
	* `char*p[]="hello";` 和 `char(*p)[]="hello";` 分别代表什么？
 	* 答： 以上两种写法都有错误。在 VS2015 里，第一种写法报语法错误，第二种写法报 warning。我们来看一下。
 	* `char*p[]` 表示定义一个数组p，它里面装的全是`char*`。你用一个字符串常量给一个装指针的数组赋值是不合乎语法的。
 	* `char(*p)[]` 表示定义一个指向`char(*)[0]`的指针p。你用一个字符串常量给一个指针赋值是有问题的，所以编译器报了 warning：
`“char (*)[0]”与“char [6]”的间接级别不同`
* 今天学的是 ++ 和 * 的优先级
	* ++ 和 * 都是单目运算符，都属于优先级为 2，是同优先级。
	* 而单目运算符的结合方向是从右向左。
	* `char* p = "hello";` ，看一下这两种写法：`*p++` 和 `++*p`
	* `*p++` 等同于 `*(p++)` 会先把p加1，再取这个地址中的值。 `++*p` 等同于 `++(*p)` 会先取出p地址上的值，对它进行加加。
	* 因为常量的值不能改变，所以 `++*p` 是错误的写法，会在运行时出错（对只读地址——RO. Data Segment 进行了写操作）
* 背一下运算符优先级吧，还是有用的。总加小括号显得你是个低手，更主要的是你看别人的代码时会懵逼。  
	* 百度了一下，觉得按这个背不错： http://blog.csdn.net/skywalker_leo/article/details/6237222
	* 今天先把优先级最高的4个背下来吧，4个初等运算符：`[]，()，->, .`
	* 再把优先级第二高的背一下，9个单目运算符：`-，(类型)，++，--，*，&，!，~，sizeof`

## const char* str 指的是什么不可变
* 指针本身是可以修改的，可以让它指向别的地方。`str++， str = "balabala"` 都是合法的
* 指针所指向的内容是不可修改的，`(*str) = 'H'， *(str+3) = 'D'` 都是不合法的。

		char str[10] = "hello";
		const char* p = str;
		p++;  // 合法。const char* 指针本身是可以改变的，可以让它指向别的地方
		printf("%c\n",*p); // 打印 e
		(*p) = 'E'; // 非法。const char* 指针代表的内容是不可修改的。

## 常用的字符串函数 （<string.h>）
* strcpy 和 strcnpy：

 		char *strcpy(char *dest, const char *src); // dest 如果不够大，会越界。
		char *strncpy(char *dest, const char *src, size_t n); // 只拷贝n个字节，但是最后的\0可能考不过去。
* C语言处理字符串麻烦，这也是没办法的事。但只有C语言可以直接操作内存：找到一个地址，把里面的数改变。这样既高效，又危险。
* strcmp 和 strncmp

		int strcmp(const char *s1, const char *s2);
		int strncmp(const char *s1, const char *s2, size_t n);
	*  s1 小于 s2 返回负数，大于返回正数，相等返回0


## 野指针与NULL
* 野指针

		char *p;   // 野指针。p是栈空间上的一个未初始化的值，它的内容是脏数据，p可能指向任何地方
		char str[10] = "hello"; 
		*p = str[0]; // 如果p指向的地方可写，则这里赋值能成功，但是很危险，会覆盖掉有用的数据。如果p指向不可写的地方，则运行到此处程序出错。

* 对于未初始化的局部变量，不同编译器的行为不一样
	* VS2015 不允许使用未初始化的局部变量，直接报 error ，编译通不过

			int i;
			printf("i=%d",i); //报错：使用了未初始化的局部变量“i”
	* 所以在 VS2015 里是不可能出现上述的‘野指针’情况的。
	* gcc（4.8.2） 允许使用未初始化的局部变量，gcc给他一个初始值
	
			#include<stdio.h>
			int main()
			{
			    int i;  
			    char c;
			    double d;
			    char* p;
			    printf("i=%d, c=%d, d=%lf, p=%p\n",i,c,d,p);
			}
			
			/* 结果 */
			i=0, c=0, d=0.000000, p=(nil)
	* 不要使用未初始化的变量，很危险。即便 gcc 给了初始值，但这个值是不可信任的。
* NULL 
	* NULL不是C语言的关键字，它在某些个C标准库文件中被定义为： `#define NULL (void *)0`
	* NULL 实际上就是 `(void *)0`，即把数字0强转为 `void*` 类型，即指向地址 0 的 void 型指针
	* 0 这个地址是可读不可写的。
	* 我们可以用 NULL 来初始化指针，避免使用野指针。
	
			char *p = NULL;
			printf("p=%p\n",p);
			/* VS2015 输出： p=00000000 */
			/* gcc 输出： p=(nil) */