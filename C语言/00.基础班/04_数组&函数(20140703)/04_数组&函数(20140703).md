## 数组
* 数组名表示的就是数组的首地址
	* &a == a == &a[0]  都等于数组a的首地址
* &a 和 a 是一回事儿吗？
	* 虽然 &a == a，但他俩不是一回事。
	* a 表示数组的首地址，即数组首个元素的地址，其本质上上一个指向int的指针
	* &a 表示数组的地址，它代表着整个数组的地址
	* 他俩之所以相等，是因为数组首个元素的地址等于数组的地址
* 注意，对地址进行加减操作的时候，加减的量，是这个地址代表的类型的长度。
* 比如对一个 int 类型的地址加1，则地址增大4字节。
* 所以，a+1 == &a[1]
* 看以下代码：

		int a[5] = { 1, 2, 3, 4, 5 };
		printf("&a[0]+1=%p\ta+1=%p\t&a+1=%p\n", &a[0]+1, a+1, &a+1);
* `&a[0]+1`： a[0]这个int的地址增大sizeof(int)
* `&a+1`：a这个数组的地址增大sizeof(a)
* `a+1`： a这个指向int的指针增大sizeof(int)


## 作业
* 
		#include "stdafx.h"
		#include <Windows.h>
		
		// 作业1：判断一个整数有多少位
		int ten_n(unsigned int n) 
		// 求10的n次方
		{
			int result = 1;
			while (n > 0)
			{
				result *= 10;
				n--;
			}
			return result;
		}
		int int_len(int i)
		{
			if (i < 0) i = -i;
			int n = 1;
			// int 的最大值也不可能超过10位数，所以这里算到10就可以了
			for (; n < 10; n++)
			{
				if (i <= (ten_n(n)-1) && i > ten_n(n-1)) return n;
			}
			return -1;
		}
		
		// 作业2：是否质数
		int is_prime_numbe(unsigned int i)
		// 是质数返回1，不是质数返回0，参数错误返回-1
		{
			if (i <= 1) return -1;
			
			for (unsigned int j = i-1; j>1; j--)
			{
				if (i%j == 0) return 0;
			}
		
			return 1;
		}
		
		//作业3：实现从1*2+3*4+5*6...+99*100的递归函数
		int cheng(int n)
		// 这种简单方法是错的，没用到递归，而且只能计算1到100的
		{
			return n*(n+1);
		}
		int calc()
		{
			int sum = 0;
			for (int n = 1; n < 100; n+=2)
			{
				sum+=cheng(n);
			}
			return sum;
		}
		
		int recu_calc(int start, int end)
		// 用递归实现作业3
		{
			if (end - start == 1) return start*end;
			else return recu_calc(start, start + 1) + recu_calc(start + 2, end);
		}
		
		int main()
		{
			//作业1
			int y = 345678;
			int n = int_len(y);
			printf("y=%d,y的位数是：%d\n",y,n);
		
			//作业2
			int x = 213;
			if (is_prime_numbe(x)) printf("x=%d,x是质数\n",x);
			else printf("x=%d,x不是质数\n", x);
		
			//作业3
			int r1 = calc();
			int r2 = recu_calc(1,100);
			printf("用方法1计算：1*2+3*4+5*6+....+99*100=%d\n",r1);
			printf("用方法2计算：1*2+3*4+5*6+....+99*100=%d\n", r2);
			system("pause");
			return 0;
		}
