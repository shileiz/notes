## 常量与变量

### 基础习题
* scanf 连续读入3个字符串而不让用户输入3次回车，这是不行的

		int i;
		char s[3];
		scanf("%d,%s",&i,s); //正确。用户输入 200,hi 回车。 i=200，s={hi\0}
		scanf("%s,%d",s,&i); //错误。用户输入 hi,200 回车。 s={hi,}，i没有被scanf读入任何数。
* 背：ASICII 码： 65='A'，97='a'，48='0'，10='\n'
* 输入输出 `%` 要用 `%%` ，而不是 `\%`。输入输出 `\` 才是用 `\\` 。

		scanf("%d%%%d",&i,&j); //用户输入 1%2 回车
		printf("%d\\%d",i,j);  //打印 1\2

### 进阶习题
* 注意！！！ double 类型的变量在 printf/scanf 里，要用 %lf，而不能用 %f。
* printf 只有十六进制，8进制输出，没有2进制
* 求一个自然数的二进制表示里有多少个1，这道题有很多种解法，这里只用最基本的解法即可。


## 基础数据类型

### 基础习题
* 运算符优先级
	* 同一优先级的运算符，运算次序由结合方向来决定
	
			* 与 / 具有相同的优先级别，其结合方向为自左向右，因此 3 * 5 / 4 的运算次序是先乘后除
			- 和 ++ 为同一优先级，结合方向为自右向左，因此 - i ++ 相当于 - ( i ++ )
	* 只有以下几类运算符是从右向左结合的：单目运算符，三目运算符，赋值运算符
	* 今天要背的是，算数运算符：乘除取余的优先级是3，加减的优先级是4，移位的优先级是5。
	* 小结一下：优先级排名前5的按顺序是： 初等，单目，算数（乘除取余，加减，移位）

* 第2题详细分析

		//第2题：求以下程序中，x + a % 3 * (int)(x + y) % 2 / 4 的值是多少？
		//int a = 7;
		//float x = 2.5, y = 4.7;
		//x + a % 3 * (int)(x + y) % 2 / 4
		/*
			分析：此表达式中运算优先级排序
			1：优先级最高的是(x+y),初等运算符优先级为1。所以第1步计算 (x + y)。
			2：(int)单目运算符优先级为2。所以第2步计算 	(int)(x + y)
			3：剩下的运算符都是算数运算符，其中乘除取余都是优先级3，加减法优先级4。
			   而算数运算符结合顺序为左到右。所以第3步应该是乘除取余中最左边的那个：a % 3
			4: 继续进行从左到右的乘法：a % 3 * (int)(x + y)
			5：继续进行从左到右的取余：a % 3 * (int)(x + y) % 2
			6：继续进行从左到右的除法：a % 3 * (int)(x + y) % 2 / 4
			7：最后进行优先级最低的加法：x + a % 3 * (int)(x + y) % 2 / 4
			分析：计算中的类型隐转
			1：(x + y)： 两个都是 float，没有混合运算直接加，结果是 7.2
			2：(int)(x + y)：float 强转 int，小数部分丢失，结果是 7
			3：a % 3：取余运算只能对整数进行，这里 a 和 3 都是整数，没有问题。结果是 1
			4：a % 3 * (int)(x + y)：相当于1 * 7，两个整数相乘，结果是整数 7
			5：a % 3 * (int)(x + y) % 2：相当于 7 % 2，结果是整数 1
			6：a % 3 * (int)(x + y) % 2 / 4：相当于 1 / 4 ，两个整数相除，结果是整数 0
			   这里要注意，虽然 1/4=0.25，但这里整数除以整除，结果还是整数，小数部分被直接舍去了
			7：x + a % 3 * (int)(x + y) % 2 / 4：相当于 2.5 + 0，浮点加整数，都转换为double计算，结果是double型的 2.5
		*/
		int a = 7;
		float x = 2.5, y = 4.7;
		double d;
		d = x + a % 3 * (int)(x + y) % 2 / 4;
		printf("%lf",d); // 2.500000

## 控制语句

### 基础习题

##### 关于 scanf 和回车（第4题）
* 看以下程序：

		while(1)
		{
			scanf("%c",&input);
			// 根据 input 的不同做不同的事
		}
* 以上程序只有第一次循环能正确，第二次循环时，input 就变成了 '\n'
* 当程序调用 scanf() 时，程序就等着用户按键。
* 用户输入的字符被存放在键盘缓冲区中，**直到用户按回车为止**。回车字符也放在缓冲区中。
* 此时 scanf() 开始冲缓冲区读入数据。第一次循环时，缓冲区里放着用户按的字符和回车符。scanf() 读出用户字符后返回，程序正常。
* 当第二次循环时，缓冲区里是：回车、用户第二次的输入、回车。这时 scanf() 读到的就是回车了，跟预期结果不同。
* 可以这么修改：

		while(1)
		{
			scanf("%c",&input);
			getchar(); // 让getchar()去把缓冲区里的回车读出来，起到清空缓冲区的作用。
		}
