## 二维数组

#### 二维数组
* 最直观的理解是：行、列。`int a[3][5];` 一个3行5列的矩阵。
* a每加1移动一行。a初始指向第一行的第一个元素，而a+1指向第二行的第一个元素。

#### 二维数组与指向数组的指针（行指针）
* 二维数组有点类似于指向数组的指针。
* 定义一个指向数组的指针要这样（还记得吗？）： `int(*p)[5];` p 是一个指向 int[5] 的指针。
* 二维数组 `int a[][5];` 可以理解为 a 是一个指向 int[5] 的指针。
* 根据以上，`int(*p)[5];` / `int a[][5];` p 和 a 被称作‘行指针’，因为他们是指向一行的指针。他们每加1,跨越一行。
*  `int a[3][5];` 可以理解为 a 是一个长度为3的数组，a 里面装了 3 个 int[5] 类型的数组。
* 换句话说，你可以理解为 a 是一个装了类型为 int[5] 的元素的数组。 

#### 为什么定义二维数组时，可以不写行数只写列数？
* 根据上面的理解，a 是一个装了类型为 int[?] 的元素的数组，你连?是几都不说显然是不行的，这相当于没有告诉编译器a里面装的是啥类型。
* int[2] 和 int[5] 可是两种完全不同的类型！

#### 一维/二维数组的初始化
* `int a[];` 是非法的，VS2015 会报错说，a:未知的大小。
* 而 `int a[] = {1，2};` 是合法的，因为编译器会从初始化的值中，得知a的长度为2.
* 二维数组也是同样的道理
* `int a[][5];` 非法，你没告诉编译器a多长。VS2015 会报错说，a:未知的大小。
* 而  `int a[][5] = {{1,2,3,4,5}};` 是合法的，相当于你告诉了编译器a的长度是1。

#### 数组作为参数传递
* 先看一维数组：当你定义一个函数的时候，`void foo(int a[], int n){...}`
* （还记得吗？）首先，因为数组会退化为指针，所以你要多传一个参数 n 来告诉函数，这个数组有多长。
* 其次，你的形参写的是 `int a[]`，而不是 `int a[5]`，因为你只需要告诉编译器，这个参数是一个 `int[]` 型的就可以了。对了，因为退化的问题，编译器实际上只会拿它当成 `int*` 来用。
	* 其实，即便你定义函数的时候，写的是  `void foo(int a[5]){...}`（这样写是合法的）
	* 这个 5 也是没用的。编译器只会知道 a 是一个指向 int 的指针，不知道 a 多长。
* 二维数组同理。当你书写函数的形参的时候，直接写 `int a[][5]` 是合法的，因为这时你只是在告诉编译器，形参 a 的类型是 `int [][5]`，即指向`int[5]` 的指针。
