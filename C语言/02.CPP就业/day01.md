### 课程介绍
* 操作符重载会重点讲

### 开始C++

#### 头文件
* 除了 .h 还支持 .hpp 和没有后缀名的文件作为头文件（ iostream 就是没有后缀名的文件 ）

#### namespace
* 用 namespace 关键字定义 namespace
* 用 using namespace 关键字使用 namespace 
* cout 和 cin 都是 std 这个 namespace 里的类
* 如果不使用 using namespace std; 来声明使用了 std 这个 namespace，也可以用 std::cout 这种来使用 cout

#### 更严格的**指针**类型转换
* 复习C的类型转换： 00基础\02.  当年之关注了“数字”类型的互相转换
	* 隐转和强转
	* 三种发生隐转的场景
	* 只有整数转整数才有“高位扩充或截断”
* C++有何不同？ 不同类型指针相互赋值属于语法错误
	* 对“数字”，应该跟C都一样
	* 对指针，C允许把指向a类型的指针赋值给指向b类型的指针变量，只会 warning
	* 而在 C++ 里，这是非法的，指针必须指向相同的类型才能赋值，如果不同，必须强转。 
	
			int(*a)[10] = {0};
			int(*b)[5] = {0};
			b = a;
			// VS2015, 后缀名是.c的情况下: warning C4048: “int (*)[5]”和“int (*)[10]”数组的下标不同
			// VS2015, 后缀名是.cpp的情况下: 不用编译就标红波浪线了：不能将 "int (*)[10]" 类型的值分配到 "int (*)[5]" 类型的实体
			b = (int(*)[5])a; // C++ 要这么搞
	
* 扩展（C复习）：00基础\04. `int (*)[5]`赋值给`int (*)[10]`仅仅会报 warning。

#### 其他·杂项
* C 和 C++ 都有的 volatile 关键字，告诉编译器不要对这个变量进行优化
* C++ 增加了一种数据类型： bool 型，值只能是 true 和 false

#### new 和 delete
* new 的作用是在堆空间上分配一块内存，相当于 C 语言里的 malloc 函数
* new 出来的内存要用 delete 释放，相当于 C 语言里的 free 函数
* 基本数据类型也可以 new 出来，跟 malloc 一样
	* Java 的基本数据类型就不能 new 出来，会报语法错误。 
	* 因为 Java 没有指针，你 new 出来一个 int，用什么变量去接收它呢？所以不能 new int 出来。
* new 返回的是指针，指向分配出来的那片内存的首地址，跟 malloc 一样
	* `int *p = new int;` 这样是合法的。
	* `delete p` 用完之后要释放。
* 可以在 new 的同时给变量赋值： `int *p = new int(10);`: 在堆空间分配一个int大小的内存，并初始化这个int为10。
* new 在堆空间上分配数组
	* 分配：  `int *p = new int[10];`
	* 释放： `delete []p;` // p前面必须要写中括号，不然只会释放第一个int的内存，造成内存泄漏。
	* 对比C：malloc 的参数不是一个类型，而是一个表示大小的数字，所以不存在这个问题
		* 分配： `int *p = malloc(sizeof(int)*10);` 
		* 释放： `free(p);`

#### 内联函数(C 和 C++ 都有)
* inline 关键字写在函数定义的地方：
	
		inline int mymax(int a ,int b){...}
* 内联函数不作为函数调用，而是直接把内联函数的代码嵌入到调用的语句中，类似于宏展开，目的是提高效率
* 内联函数解决了宏展开的歧义问题
* inline 只是对编译器的建议，具体内部内联还要看编译器认为你这个函数到底够不够“小”（比如内联函数内不允许用循环语句和开关语句，不能递归）
* 内联函数在逻辑上跟普通函数一样，只是为了提高效率，不会 inline 了就改变了预期结果

#### 引用
* 在定义函数时写作 `void func(int &a, char * &b){...}` 这种形式，调用时还按原来的形式：`func(i, p);`
* 定义引用变量时必须同时初始化` int &c = a; //合法`，要不然不知道这个引用是谁的别名 `int &c; //非法`。
* 引用不能被改变，` int &c = a; c = b; //非法`
* 问题1： const 引用作为函数参数？

#### 缺省参数
* 有缺省值的参数后面不能再出现无缺省值的参数（跟 python 一样）
* 扩展：python 的 keyword argument 
	* 指的是在调用函数时，可以不按定义函数时的顺序写参数，而按 `形参=实参` 这种形式调用。
	* 无论在定义函数时有没有缺省值的参数都可以这么搞，所以 keyword argument 是**调用**函数时的一个名词
	* 与其对应的是 positional argument，也是在**调用**函数时，按位置传参数。
	* 而有默认值和无默认值的参数，是**定义**函数时的名词。
* 扩展： python 函数调用传的是值还是引用？
	* 可以说既不是传值也不是传引用，也可以说成永远是传递引用
	* 参考以下帖子：
	* http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/
	* 参考《python 中的内存地址》
