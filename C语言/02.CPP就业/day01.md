### 课程介绍
* 操作符重载会重点讲

### 开始C++

#### 头文件
* 除了 .h 还支持 .hpp 和没有后缀名的文件作为头文件（ iostream 就是没有后缀名的文件 ）

#### namespace
* 用 namespace 关键字定义 namespace
* 用 using namespace 关键字使用 namespace 
* cout 和 cin 都是 std 这个 namespace 里的类
* 如果不使用 using namespace std; 来声明使用了 std 这个 namespace，也可以用 std::cout 这种来使用 cout

##### 定义自己的 namespace
* 可以定义没有名字的 namespace，里面的函数中外部将不可用
* static 的函数，只能在文件内部使用
* 无名 namespace 包起来整个文件也可以起到整个文件的函数只能在文件内有效的效果，很少这么用

#### 更严格的指针类型转换
* 复习C的类型转换： 00基础\02.  当年之关注了“数字”类型的互相转换
	* 隐转和强转
	* 三种发生隐转的场景
	* 只有整数转整数才有“高位扩充或截断”
* C++有何不同？ 不同类型指针相互赋值属于语法错误
	* 对“数字”，应该跟C都一样
	* 对指针，C允许把指向a类型的指针赋值给指向b类型的指针变量，只会 warning
	* 而在 C++ 里，这是非法的，指针必须指向相同的类型才能赋值，如果不同，必须强转。 
	
			int(*a)[10];
			int(*b)[5];
			b = a;
			// VS2015, 后缀名是.c的情况下: warning C4048: “int (*)[5]”和“int (*)[10]”数组的下标不同
			// VS2015, 后缀名是.cpp的情况下: 不用编译就标红波浪线了：不能将 "int (*)[10]" 类型的值分配到 "int (*)[5]" 类型的实体
			b = (int(*)[5])a; // C++ 要这么搞
	
* 扩展（C复习）：00基础\04. `int (*)[5]`赋值给`int (*)[10]`仅仅会报 warning。


#### new 和 delete
* new 的作用是在堆空间上分配一块内存，相当于 C 语言里的 malloc 函数
* new 出来的内存要用 delete 释放，相当于 C 语言里的 free 函数
* 基本数据类型也可以 new 出来，跟 malloc 一样
	* Java 的基本数据类型就不能 new 出来，会报语法错误。 
	* 因为 Java 没有指针，你 new 出来一个 int，用什么变量去接收它呢？所以不能 new int 出来。
* new 返回的是指针，指向分配出来的那片内存的首地址，跟 malloc 一样
	* `int *p = new int;` 这样是合法的。
	* `delete p` 用完之后要释放。
* 可以在 new 的同时给变量赋值： `int *p = new int(10);`: 在堆空间分配一个int大小的内存，并初始化这个int为10。
* new 在堆空间上分配数组
	* 分配：  `int *p = new int[10];`
	* 释放： `delete []p;` // p前面必须要写中括号，不然只会释放第一个int的内存，造成内存泄漏。
	* 对比C：malloc 的参数不是一个类型，而是一个表示大小的数字，所以不存在这个问题
		* 分配： `int *p = malloc(sizeof(int)*10); // 或者：int *p = malloc(sizeof(int[10]));`
		* 释放： `free(p);`

#### 内联函数(C 和 C++ 都有)
* inline 关键字写在函数定义的地方：
	
		inline int mymax(int a ,int b){...}
* 内联函数不作为函数调用，而是直接把内联函数的代码嵌入到调用的语句中，类似于宏展开，目的是提高效率
* 内联函数解决了宏展开的歧义问题
* inline 只是对编译器的建议，具体内部内联还要看编译器认为你这个函数到底够不够“小”（比如内联函数内不允许用循环语句和开关语句，不能递归）
* 内联函数在逻辑上跟普通函数一样，只是为了提高效率，不会 inline 了就改变了预期结果

#### 引用
* 定义引用变量时必须同时初始化` int &c = a; //合法`，要不然不知道这个引用是谁的别名 `int &c; //非法`。
* 引用不能被改变，` int &c = a; c = b; //非法`
* 在定义函数时写作 `void func(int &a, char * &b){...}` 这种形式
* 调用时还按原来的形式：`func(i, p);`，不用先定义一个引用再把引用传递给以上函数，传变量本身就可以。
* 当函数运行时，在栈空间压入两个引用型变量，引用的是实参。
* 如果要使引用参数的值不能在函数内部被修改，那么就定义为常量引用 const &
* 扩展（复习C的const指针）:00基础\06. 从右往左念，a const pointer 或者 a pointer to a const

#### 缺省参数
* 有缺省值的参数后面不能再出现无缺省值的参数（跟 python 一样）
* 扩展：python 的 keyword argument 
	* 指的是在调用函数时，可以不按定义函数时的顺序写参数，而按 `形参=实参` 这种形式调用。
	* 无论在定义函数时有没有缺省值的参数都可以这么搞，所以 keyword argument 是**调用**函数时的一个名词
	* 与其对应的是 positional argument，也是在**调用**函数时，按位置传参数。
	* 而有默认值和无默认值的参数，是**定义**函数时的名词。
* 扩展： python 函数调用传的是值还是引用？
	* 可以说既不是传值也不是传引用，也可以说成永远是传递引用
	* 参考以下帖子：
	* http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/
	* 参考《python 中的内存地址》

#### 类
* 如果类函数返回的是成员变量的指针，为了避免在类外部成员变量被修改，所以函数就要返回常量指针。
	
		class man
		{
			public:
			    char *name;
			public:
			    char *get_name() 
				/* 
					错误，返回的是 name 的地址，外面可以利用这一点重置 name 的值。
					正确做法应该是 const char *get_name()
				*/
				{
					return name；
				} 
		};

* 不过以上方法（`const char *get_name()`）也避免不了外部修改成员变量，外面可以把 `get_name()` 返回值强转成 char*，然后对其赋值。
* 老师讲到这儿也懵了，确实能通过强转赋值，老师也没说咋解决。
* 在类的内部访问全局标识,关键字 `::`


#### 构造函数
* 不用 new，定义一个类对象的时候，就会调用构造函数： `Person p;` 这句就已经调用 Person 的构造函数了。 
* Java 里不是这样，Java 里只有 `Person p = new Person();` 才会调用构造函数，`Person p;` 则不会。
* C++ 里用这种语法： `Person p(参数);` 
* Java 是`Person p = new Person(参数);`
* Python是 `p = Person(参数)`
* C++ 里类的成员变量如果不赋值，则其值是随机的。就像C里定义了一个变量却没有赋初值一样。所以一定要在构造函数里给所有的成员变量赋初值。或者在定义类的时候写上初值。
* C++ 实例化的对象是分配在栈空间的，new 出来的对象才是在堆上。
	* `Person p(10,"xiaozhang");` // 栈空间
	* `Person *p = new Person(10,"xiaozhang");` //堆空间 
* new 出来的对象，只有在 delete 的时候才会析构。
	* 在栈上分配的对象，在超出作用域的时候，会自动调用析构函数
	* new 出来的对象，只有在 delete 时才会调用析构函数
	
			void test() {
				Person *p1 = new Person(24); // test() 退出也不会析构 p1，必须手动 delete p1
				Person p2(24);  // test() 退出的时候，会自动调用析构函数
			}


##### 初始化成员列表
* 在构造函数后面直接冒号可以初始化成员变量，形如：`Person():age(10),name("xiao zhang") {....}`
* const成员必须用初始化成员列表赋值
* 引用数据成员必须用初始化成员列表赋值
* 因为const和引用都是必须在定义的时候赋值，之后不能再被赋值的，所以必须用初始化成员列表赋值。


#### 拷贝

#### 其他·杂项
* C 和 C++ 都有的 volatile 关键字，告诉编译器不要对这个变量进行优化
* C++ 增加了一种数据类型： bool 型，值只能是 true 和 false
* 不要把全局变量定义在头文件里，如果有多个.c/.cpp文件包含了同一个头文件，则编译会报错，属于重复定义变量。