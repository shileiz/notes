###  让代码不报错
* 在 tutorial04 的基础上，加上： `#include <libavutil/time.h>`

### 读 tutorial05 可以暂且认为所有视频文件都是按照解码顺序存储packet的

* 是否因为B帧的存在，才导致 `avcodec_decode_video2()` 有可能解不出来一个完整的frame？
* 先看 Tutorial05 的原文：

		B frames are the same as P frames, but depend upon information found in frames that are displayed both before and after them! 
		This explains why we might not have a finished frame after we call avcodec_decode_video2.

* 测试了40个各种格式的视频，没有一个是DTS乱序的，即读出来的 `packet.dts` 永远是递增的
* 所以不存在送给 `avcodec_decode_video2()` 的 packet 因为需要参考尚未读出来的 packet 所以解码不出来的情况，起码对这40个文件如此。
* 有些 video packet 确实解码不出来数据
* 看了这40个文件每一个 video packet 送给 `avcodec_decode_video2()` 之后，是否真的解码出来了图像，看的是 `avcodec_decode_video2()` 的第三个参数。
* 第三个参数的意义： Zero if no frame could be decompressed, otherwise, it is nonzero.
* 这40个文件里，绝大多数解不出来图像的packet是文件最开始的几个packet(1~6个)，只有一个在文件中间还有这样的packet的情况。
	* 为什么文件最开始的几个packet那么容易解不出来图像？——这个貌似跟codec相关，h264的必然前4~6帧解不出来，MPEG1、MPEG2的第一帧解不出来，h263则都能解出来。
	* 那个在文件中间部分仍然有解不出来图像的文件是否是一些损坏了的文件？ ——貌似是未授权的编码器给加密了，播放该文件时屏幕上有大大的水印：“created with a non-activated version www.avs4you.com”
* 不过这40个文件里有很多PTS是乱序的，这是很正常的，有B帧的情况下，DTS和PTS不相等很正常，有些先解码出来的需要后显示。
* 起码基于这40个文件的测试结果，Tutorial05 里说的：因为B帧的原因，所以 `avcodec_decode_video2()` 有可能解不出来一个完整的frame，是不成立的。
* 解码不出来图像可能有多种原因，其中一个可能是读packet的函数读到的packet并不是真正的视频数据：

		 * This function returns what is stored in the file, and does not validate
		 * that what is there are valid frames for the decoder. It will split what is
		 * stored in the file into frames and return one for each call. It will not
		 * omit invalid data between valid frames so as to give the decoder the maximum
		 * information possible for decoding.

### 解码之后会改变 packet 的 dts 吗？
* 测试40个视频文件，发现解码之后dts不会发生变化
* 再加上`avcodec_decode_video2`的注释：`@param[in] avpkt The input AVPacket containing the input buffer.`
* 说明 pakcet 是一个 input 参数（并且函数原型里是 const 的），所以调用解码函数，不会改变 packet 里的任何值
* 所以没必要在 decode 之后，再去计算 dts 或者 pts
* 不知道 tutorial05 这么做是为了什么？ 为了效率？ 如果解不出来图像干脆不用算pts啥的了？有可能是这个原因。

### packet 的 pts 不等于 frame 的 pts
* `av_frame_get_best_effort_timestamp` 的参数是 AVFrame
* `av_frame_get_best_effort_timestamp` 的注释写的不详细：

		 * Accessors for some AVFrame fields.
		 * The position of these field in the structure is not part of the ABI,
		 * they should not be accessed directly outside libavutil.

* Frame 也有 pts，但是不能直接访问，所以必须用这个函数来访问
* （我理解）因为一个音频 packet 可能对应多个音频 frame，所以用 packet 的 pts 无法决定一个 frame 到底该什么时候播放，还得用 frame 的
* （我理解）ffmpeg 在解码一个 packet 的时候，给解出来的 frame 设置了 pts（根据 packet 的 pts），然后我们用 `av_frame_get_best_effort_timestamp`  得到 frame 的 pts
* 我觉得对于视频来说，`av_frame_get_best_effort_timestamp` 得到的 pts，应该跟这个 frame 解码前的那个 packet 的 pts 是一样的，有待验证。
* 理解错误，经验证，一个mp4文件，每一个 video packet 解码后得到的 frame 的 pts，几乎都不等于解码前 packet 的 pts，相差 2K 到 4K 毫秒。
* 看 AVFrame 里对这个成员的定义注释：

	    /**
	     * frame timestamp estimated using various heuristics, in stream time base
	     * Code outside libavcodec should access this field using:
	     * av_frame_get_best_effort_timestamp(frame)
	     * - encoding: unused
	     * - decoding: set by libavcodec, read by user.
	     */
	    int64_t best_effort_timestamp;

* 所以说，frame 的 pts，是根据 time base 计算之后的，而不是简单的取 packet.pts。ffmpeg 为我们做好了基于 time base 和 packet.pts 计算出真正的 pts 的工作了。做的太到位了。
* 看 tutorial05 里这2段话：

>When we get a packet from `av_read_frame()`, it will contain the PTS and DTS values for the information inside that packet. But what we really want is the PTS of our newly decoded raw frame, so we know when to display it.

>Fortunately, FFMpeg supplies us with a "best effort" timestamp, which you can get via, `av_frame_get_best_effort_timestamp()`

>....

>This value (指的是 frame 的 pts) is a timestamp that corresponds to a measurement of time in that stream's time_base unit. For example, if a stream has 24 frames per second, a PTS of 42 is going to indicate that the frame should go where the 42nd frame would be if there we had a frame every 1/24 of a second (certainly not necessarily true).

>We can convert this value to seconds by dividing by the framerate. The time base value of the stream is going to be 1/framerate (for fixed-fps content), so to get the PTS in seconds, we multiply by the time base.

### `AV_NOPTS_VALUE`

		/**
		 * @brief Undefined timestamp value
		 *
		 * Usually reported by demuxer that work on containers that do not provide
		 * either pts or dts.
		 */