### 读 tutorial05 可以暂且认为所有视频文件都是按照解码顺序存储packet的

* 是否因为B帧的存在，才导致 `avcodec_decode_video2()` 有可能解不出来一个完整的frame？
* 先看 Tutorial05 的原文：

		B frames are the same as P frames, but depend upon information found in frames that are displayed both before and after them! 
		This explains why we might not have a finished frame after we call avcodec_decode_video2.

* 测试了40个各种格式的视频，没有一个是DTS乱序的，即读出来的 `packet.dts` 永远是递增的
* 所以不存在送给 `avcodec_decode_video2()` 的 packet 因为需要参考尚未读出来的 packet 所以解码不出来的情况，起码对这40个文件如此。
* 有些 video packet 确实解码不出来数据
* 看了这40个文件每一个 video packet 送给 `avcodec_decode_video2()` 之后，是否真的解码出来了图像，看的是 `avcodec_decode_video2()` 的第三个参数。
* 第三个参数的意义： Zero if no frame could be decompressed, otherwise, it is nonzero.
* 这40个文件里，绝大多数解不出来图像的packet是文件最开始的几个packet(1~6个)，只有一个在文件中间还有这样的packet的情况。
	* 为什么文件最开始的几个packet那么容易解不出来图像？——这个貌似跟codec相关，h264的必然前4~6帧解不出来，MPEG1、MPEG2的第一帧解不出来，h263则都能解出来。
	* 那个在文件中间部分仍然有解不出来图像的文件是否是一些损坏了的文件？ ——貌似是未授权的编码器给加密了，播放该文件时屏幕上有大大的水印：“created with a non-activated version www.avs4you.com”
* 不过这40个文件里有很多PTS是乱序的，这是很正常的，有B帧的情况下，DTS和PTS不相等很正常，有些先解码出来的需要后显示。
* 起码基于这40个文件的测试结果，Tutorial05 里说的：因为B帧的原因，所以 `avcodec_decode_video2()` 有可能解不出来一个完整的frame，是不成立的。
* 解码不出来图像可能有多种原因，其中一个可能是读packet的函数读到的packet并不是真正的视频数据：

		 * This function returns what is stored in the file, and does not validate
		 * that what is there are valid frames for the decoder. It will split what is
		 * stored in the file into frames and return one for each call. It will not
		 * omit invalid data between valid frames so as to give the decoder the maximum
		 * information possible for decoding.

### 解码之后会改变 packet 的 dts 吗？
* 测试40个视频文件，发现解码之后dts不会发生变化
* 再加上`avcodec_decode_video2`的注释：`@param[in] avpkt The input AVPacket containing the input buffer.`
* 说明 pakcet 是一个 input 参数（并且函数原型里是 const 的），所以调用解码函数，不会改变 packet 里的任何值
* 所以没必要在 decode 之后，再去计算 dts 或者 pts
* 不知道 tutorial05 这么做是为了什么？ 为了效率？ 如果解不出来图像干脆不用算pts啥的了？有可能是这个原因。

### `AV_NOPTS_VALUE`

### 为何要使用 `av_frame_get_best_effort_timestamp` 而不是直接 `packet.pts`