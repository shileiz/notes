### 让代码能运行
* 除了常规修改和修改音频解码部分（参考tutorial03.cpp）之外，还要做如下修改：
* `audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * 3) / 2];` 改为 `audio_buf[(MAX_AUDIO_FRAME_SIZE * 3) / 2];`
* 加入： `#include <libavutil/avstring.h>`
* 函数 `decode_thread` 里面，`AVFormatContext *pFormatCtx;` 改为 `AVFormatContext *pFormatCtx = NULL;`

### 再看 tutorial01
* 只有 packet 是分配在栈空间的，其他在栈空间只是一个指针
* 但 packet 里的 data 也还是在堆上，每次读出来一个 packet，`packet.data` 指向新读到的数据
* `av_free_packet（&packet）` 让 packet 里的 data 变成 NULL，但是 packet.dts，packet.pts 都不变。并且 packet 本身还是在栈空间上原来的位置。

### packet 入队列
* 在函数 `packet_queue_put` 里 有这个动作：`pkt1 = (AVPacketList*)av_malloc(sizeof(AVPacketList))`  
* 在堆上分配了一个 `AVPacketList`，而 `AVPacketList` 里面有一个 `AVPacket`，而不是 `AVPacket*`
* 所以在堆上分配 `AVPacketList` 的时候，会分配一个 `AVPacket` 出来，它有自己的 pts，dts，data
* 然后在函数 `packet_queue_put` 里赋值的时候：`pkt1->pkt = *pkt;` 
* `*pkt` 是栈空间上我们不停往里读数据的那个packet，这个赋值相当于把一个结构体变量赋值给另一个结构体变量，结构体里面的成员都要拷贝过去的。把栈上的拷贝到堆上的了。
* 所以下一次循环，虽然栈空上的那个 packet 被重新赋值冲掉了，但堆上已经保存了上一个packet了。


### 疑问
* `av_dup_packet` 是干嘛用的